import {b as b$1,c,a,e,d}from'../chunk-54W34GRC.js';import {b}from'../chunk-5VUAD25I.js';import {getOctokit,context}from'@actions/github';import {resolve}from'path';function M(r,o){return r?.length?o.every(({name:e,emailPrefix:s})=>r.some(t=>e&&t.name===e||s&&t.emailPrefix===s)):false}function A(r,o){return o.filter(({name:e,emailPrefix:s})=>!r.some(t=>e&&t.name===e||s&&t.emailPrefix===s))}function y(r,o,e,s){let{caporegimes:t=[],rules:i=[]}=e,n=process.cwd();if(!M(t,o))for(let l of i){if(d(r,l.match,n).length===0)continue;let f=[...t,...l.goodfellas||[]];if(l.crews&&e.crews){let a=l.crews.flatMap(u=>e.crews?.[u]).filter(Boolean);f.push(...a);}let C=M(f,o),m=!!l.allowForgiveness;if(!C&&!m){let a$1=A(l.goodfellas,o);throw s&&c(b.error),new Error(a("error",{goodfellas:f,commiters:a$1}))}}}var v=class r{octokit;constructor(){this.octokit=getOctokit(process.env.GITHUB_TOKEN||"");}static init(){return new r}getUniqueCommitersList(o){return o.reduce((e$1,{commit:s,committer:t})=>{let i=t?.login,n=e(s.author?.email);if(!i&&!n)return e$1;if(!(e$1.nameMap.has(i)||e$1.emailMap.has(n))){let l={name:i,emailPrefix:n};i&&e$1.nameMap.add(i),n&&e$1.emailMap.add(n),e$1.list.push(l);}return e$1},{nameMap:new Set,emailMap:new Set,list:[]}).list}async getCommitters(o,e=true){let{data:s}=await this.octokit.rest.pulls.listCommits({owner:context.repo.owner,repo:context.repo.repo,pull_number:o});if(!s.length)throw new Error("No commits found in this pull request.");let t=e?s:[s[0]],i=this.getUniqueCommitersList(t);if(i.length===0)throw new Error("No email or username found in commit authors metadata.");return i}getPullRequestID(){let o=context.payload?.pull_request?.number;return o||(console.log(b.error,"No pull request number found."),process.exit(1)),o}async getModifiedFiles(o){let{data:e}=await this.octokit.rest.pulls.listFiles({owner:context.repo.owner,repo:context.repo.repo,pull_number:o});return e.map(s=>resolve(s.filename))}getRelevantReviewers(o,e,s){let{caporegimes:t=[],rules:i=[]}=s,n=s.codeReviews?.autoAssignCaporegimes?t:[],d$1=[],l=process.cwd();for(let m of o){let a=i.find(u=>d([m],u.match,l).length>0);a&&(a.crews&&d$1.push(...a.crews),n.push(...a.goodfellas||[]));}let G=n.filter(({name:m,emailPrefix:a})=>!e.some(u=>m&&u.name===m||a&&u.emailPrefix===a)),f=[...new Set(G.map(({name:m})=>m).filter(Boolean))],C=[...new Set(d$1)];return {reviewers:f,crews:C}}async assignReviewers(o,e,s,t){let{reviewers:i,crews:n}=this.getRelevantReviewers(e,s,t);if(i.length!==0)return await this.octokit.rest.pulls.requestReviewers({owner:context.repo.owner,repo:context.repo.repo,pull_number:o,reviewers:i,...n.length>0?{team_reviewers:n}:{}})}};(async()=>{try{console.log("process.env.GITHUB_ACTIONS",process.env.GITHUB_ACTIONS),console.log("process.env.CI",process.env.CI),!process.env.CI&&process.env.GITHUB_ACTIONS!=="true"&&(console.log("\u{10102} This script is intended to run inside GitHub Actions."),process.exit(1)),process.env.GITHUB_TOKEN||(console.log(b.error,"\u{10102} GITHUB_TOKEN is missing. Make sure it's passed via `env:` in your workflow."),process.exit(1));let r=await b$1(),o=r.options?.showAscii??!0,e=v.init(),s=e.getPullRequestID(),t=await e.getCommitters(s,r.options?.vouchForAllCommiters),i=await e.getModifiedFiles(s);y(i,t,r,o),((r.codeReviews?.autoAssignGoodfellas??!0)||r.codeReviews?.autoAssignCaporegimes)&&await e.assignReviewers(s,i,t,r),o&&c(b.success),console.log(a("success",{commiters:t})),process.exit(0);}catch(r){let o=r instanceof Error?r.message:String(r);console.log(b.error,o),process.exit(1);}})();